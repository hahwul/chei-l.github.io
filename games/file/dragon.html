<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>독수리와 용, 그리고 피카츄와 라이츄</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #e0f2f7; /* 하늘색 배경 */
            font-family: "Inter", sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            color: #333;
        }
        h1 {
            color: #2196f3;
            margin-bottom: 20px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }
        canvas {
            display: block;
            background-color: #87ceeb; /* 하늘색 */
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            touch-action: none; /* 터치 이벤트 기본 동작 방지 */
        }
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
        }
        button {
            background-color: #4CAF50; /* 초록색 */
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            font-size: 1.1em;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
            outline: none;
        }
        button:hover {
            background-color: #45a049;
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.3);
        }
        button:active {
            transform: translateY(0);
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
        }
        button.reset {
            background-color: #f44336; /* 빨간색 */
        }
        button.reset:hover {
            background-color: #da190b;
        }
        /* 메시지 박스 스타일은 이제 필요 없으므로 숨김 */
        .message-box {
            display: none;
        }
    </style>
</head>
<body>
    <h1>독수리와 용, 그리고 피카츄와 라이츄</h1>
    <canvas id="animationCanvas"></canvas>
    <div class="controls">
        <button id="startButton">애니메이션 시작</button>
        <button id="resetButton" class="reset">다시 시작</button>
    </div>

    <script>
        // 전역 변수 선언
        let scene, camera, renderer;
        let eagleGroup, dragonGroup, pikachuGroup, raichuGroup;
        let eagleBody, eagleHead, eagleLeftWing, eagleRightWing, eagleTail, eagleLeftLeg, eagleRightLeg; // 독수리 각 부분 참조
        let dragonBody, dragonHead, dragonLeftWing, dragonRightWing, dragonTail; // 용 각 부분 참조
        let eagleWings = [];
        let dragonWings = [];
        let bloodParticles = [];
        let healingParticles = []; // 치유 파티클을 저장할 배열
        let clouds = []; // 구름을 저장할 배열
        let ground; // 땅 객체
        let meatObject; // 고기 객체
        let animationFrameId;
        let isAnimating = false;
        let eagleSpeed = 0.05;
        let dragonSpeed = 0.03;
        let dragonAppeared = false;
        let eagleDying = false;
        let mouseX = 0, mouseY = 0;
        let targetRotationX = 0, targetRotationY = 0;
        let currentRotationX = 0, currentRotationY = 0;
        const rotationSpeed = 0.05;
        let wingFlapTime = 0;
        let cameraShakeActive = false; // 카메라 흔들림 활성화 여부
        let cameraShakeIntensity = 0; // 카메라 흔들림 강도

        let speechInProgress = false; // 음성 재생 중인지 확인하는 플래그
        let voices = []; // 사용 가능한 음성 목록
        let selectedVoice = null; // 선택된 한국어 음성

        // 애니메이션 상태 관리
        const GameState = {
            INITIAL: 0,
            EAGLE_FLYING: 1,
            DRAGON_APPEARING: 2,
            COLLISION: 3,
            EAGLE_FALLING: 4,
            EAGLE_FALLEN: 5,
            ENCOUNTER_POKEMON: 6,
            EAGLE_REVIVING: 7,
            EAGLE_FLYING_AWAY: 8,
            DRAGON_EATING: 9,
            FINISHED: 10
        };
        let currentGameState = GameState.INITIAL;
        let stateTimer = 0; // 각 상태에서 머무는 시간 측정
        const stateDurations = { // 상태별 최소 유지 시간 (프레임)
            [GameState.EAGLE_FALLEN]: 120, // 2초
            [GameState.ENCOUNTER_POKEMON]: 240, // 4초
            [GameState.EAGLE_REVIVING]: 180, // 3초
            [GameState.DRAGON_EATING]: 240 // 용이 고기 먹는 시간 (4초)
        };

        // 음성 합성 초기화 및 한국어 음성 선택
        function initSpeechSynthesis() {
            // voiceschanged 이벤트 리스너를 추가하여 음성 목록이 로드될 때마다 업데이트
            window.speechSynthesis.onvoiceschanged = () => {
                voices = window.speechSynthesis.getVoices();
                // 한국어 음성 중 하나를 선택
                selectedVoice = voices.find(voice => voice.lang === 'ko-KR') || null;
                if (!selectedVoice) {
                    console.warn("한국어 음성을 찾을 수 없습니다. 기본 음성을 사용합니다.");
                    // 기본 음성 사용을 원하면 여기에 추가 로직 구현
                } else {
                    console.log("한국어 음성 선택:", selectedVoice.name);
                }
            };

            // onvoiceschanged 이벤트가 이미 발생했을 경우를 대비하여 초기 호출
            if (window.speechSynthesis.getVoices().length > 0) {
                window.speechSynthesis.onvoiceschanged();
            }
        }

        // 음성 메시지 재생 함수
        function speakMessage(message) {
            if ('speechSynthesis' in window) {
                // 이전 음성 중지
                window.speechSynthesis.cancel();

                const utterance = new SpeechSynthesisUtterance(message);
                utterance.lang = 'ko-KR'; // 한국어 설정
                utterance.rate = 1.2; // 속도 조절 (살짝 빠르게)
                utterance.pitch = 1.5; // 음높이 조절 (더 귀엽게)

                // 선택된 한국어 음성이 있다면 적용
                if (selectedVoice) {
                    utterance.voice = selectedVoice;
                }

                utterance.onstart = () => {
                    speechInProgress = true;
                };
                utterance.onend = () => {
                    speechInProgress = false;
                };
                utterance.onerror = (event) => {
                    console.error('SpeechSynthesisUtterance.onerror', event, "message:", message);
                    speechInProgress = false;
                };

                window.speechSynthesis.speak(utterance);
            } else {
                console.warn("Speech Synthesis Not Supported in this browser.");
            }
        }

        // 독수리 모델 생성 함수 (더 현실적인 느낌)
        function createEagle() {
            const eagleMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513, flatShading: true }); // 갈색 독수리
            const headMaterial = new THREE.MeshPhongMaterial({ color: 0xF8F8F8, flatShading: true }); // 흰색 머리 (흰꼬리수리처럼)
            const beakMaterial = new THREE.MeshPhongMaterial({ color: 0xFFA500, flatShading: true }); // 주황색 부리
            const legMaterial = new THREE.MeshPhongMaterial({ color: 0xDAA520, flatShading: true }); // 다리 색

            eagleGroup = new THREE.Group();

            // 몸통 (더 부드러운 구 형태)
            const bodyGeometry = new THREE.IcosahedronGeometry(0.8, 1);
            eagleBody = new THREE.Mesh(bodyGeometry, eagleMaterial);
            eagleBody.position.y = 0.2;
            eagleGroup.add(eagleBody);

            // 머리 (작은 구)
            eagleHead = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 16), headMaterial);
            eagleHead.position.set(0.7, 0.5, 0);
            eagleGroup.add(eagleHead);

            // 부리 (뾰족한 원뿔)
            const beak = new THREE.Mesh(new THREE.ConeGeometry(0.15, 0.5, 8), beakMaterial);
            beak.position.set(1.0, 0.5, 0);
            beak.rotation.z = Math.PI / 2;
            eagleGroup.add(beak);

            // 눈 (작은 검은 구)
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const leftEye = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), eyeMaterial);
            leftEye.position.set(0.8, 0.6, -0.2);
            eagleHead.add(leftEye); // 머리에 눈을 붙임

            const rightEye = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), eyeMaterial);
            rightEye.position.set(0.8, 0.6, 0.2);
            eagleHead.add(rightEye); // 머리에 눈을 붙임


            // 왼쪽 날개
            const leftWingGeometry = new THREE.BoxGeometry(0.1, 0.6, 2.5); // 길고 얇은 상자
            eagleLeftWing = new THREE.Mesh(leftWingGeometry, eagleMaterial);
            eagleLeftWing.position.set(-0.5, 0.2, -1.2);
            eagleLeftWing.rotation.y = -Math.PI / 2;
            eagleGroup.add(eagleLeftWing);
            eagleWings.push(eagleLeftWing);

            // 오른쪽 날개
            const rightWingGeometry = new THREE.BoxGeometry(0.1, 0.6, 2.5);
            eagleRightWing = new THREE.Mesh(rightWingGeometry, eagleMaterial);
            eagleRightWing.position.set(-0.5, 0.2, 1.2);
            eagleRightWing.rotation.y = Math.PI / 2;
            eagleGroup.add(eagleRightWing);
            eagleWings.push(eagleRightWing);

            // 꼬리
            const tailGeometry = new THREE.ConeGeometry(0.3, 0.8, 8);
            eagleTail = new THREE.Mesh(tailGeometry, eagleMaterial);
            eagleTail.position.set(-1.0, 0.0, 0);
            eagleTail.rotation.z = -Math.PI / 2;
            eagleGroup.add(eagleTail);

            // 왼쪽 다리
            const legGeometry = new THREE.BoxGeometry(0.1, 0.5, 0.1);
            eagleLeftLeg = new THREE.Mesh(legGeometry, legMaterial);
            eagleLeftLeg.position.set(-0.2, -0.5, -0.2);
            eagleGroup.add(eagleLeftLeg);

            // 오른쪽 다리
            eagleRightLeg = new THREE.Mesh(legGeometry, legMaterial);
            eagleRightLeg.position.set(-0.2, -0.5, 0.2);
            eagleGroup.add(eagleRightLeg);

            eagleGroup.scale.set(0.8, 0.8, 0.8);
            eagleGroup.position.set(-8, 2, 0); // 초기 위치
            return eagleGroup;
        }

        // 용 모델 생성 함수 (더 현실적인 느낌)
        function createDragon() {
            const dragonMaterial = new THREE.MeshPhongMaterial({ color: 0x228B22, flatShading: true }); // 어두운 초록색 용
            const hornMaterial = new THREE.MeshPhongMaterial({ color: 0x808080, flatShading: true }); // 회색 뿔
            const spineMaterial = new THREE.MeshPhongMaterial({ color: 0x006400, flatShading: true }); // 더 어두운 초록색 등뼈

            dragonGroup = new THREE.Group();

            // 몸통 (구불구불한 튜브 형태)
            const curve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(-1, 0.5, 0.5),
                new THREE.Vector3(-2, 0, 0),
                new THREE.Vector3(-3, -0.5, -0.5),
                new THREE.Vector3(-4, 0, 0)
            ]);
            const tubeGeometry = new THREE.TubeGeometry(curve, 20, 0.6, 8, false); // 경로, 세그먼트, 반지름, 방사형 세그먼트, 닫힘 여부
            dragonBody = new THREE.Mesh(tubeGeometry, dragonMaterial);
            dragonGroup.add(dragonBody);

            // 등뼈 (튜브 몸통 위에 작은 원뿔들을 연결)
            const spineCount = 15;
            for(let i = 0; i < spineCount; i++) {
                const point = curve.getPoint(i / (spineCount - 1));
                const spineGeometry = new THREE.ConeGeometry(0.15, 0.3, 4);
                const spine = new THREE.Mesh(spineGeometry, spineMaterial);
                spine.position.copy(point);
                spine.position.y += 0.5; // 몸통 위로
                dragonGroup.add(spine);
            }

            // 머리 (더 큰 구)
            dragonHead = new THREE.Mesh(new THREE.SphereGeometry(0.8, 16, 16), dragonMaterial);
            dragonHead.position.x = 0.5;
            dragonGroup.add(dragonHead);

            // 눈 (작은 노란 구)
            const dragonEyeMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFF00 });
            const dLeftEye = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), dragonEyeMaterial);
            dLeftEye.position.set(0.8, 0.4, -0.4);
            dragonHead.add(dLeftEye);

            const dRightEye = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), dragonEyeMaterial);
            dRightEye.position.set(0.8, 0.4, 0.4);
            dragonHead.add(dRightEye);

            // 콧구멍 (작은 검은 원기둥)
            const nostrilMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const leftNostril = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.1, 8), nostrilMaterial);
            leftNostril.position.set(1.0, 0.2, -0.2);
            dragonHead.add(leftNostril);

            const rightNostril = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.1, 8), nostrilMaterial);
            rightNostril.position.set(1.0, 0.2, 0.2);
            dragonHead.add(rightNostril);

            // 뿔 (원뿔)
            const hornGeometry = new THREE.ConeGeometry(0.2, 0.6, 8);
            const leftHorn = new THREE.Mesh(hornGeometry, hornMaterial);
            leftHorn.position.set(0.8, 1.0, -0.4);
            leftHorn.rotation.z = Math.PI / 6;
            dragonGroup.add(leftHorn);

            const rightHorn = new THREE.Mesh(hornGeometry, hornMaterial);
            rightHorn.position.set(0.8, 1.0, 0.4);
            rightHorn.rotation.z = -Math.PI / 6;
            dragonGroup.add(rightHorn);

            // 왼쪽 날개 (얇은 상자)
            const leftDragonWingGeometry = new THREE.BoxGeometry(0.1, 2.5, 2.0);
            dragonLeftWing = new THREE.Mesh(leftDragonWingGeometry, dragonMaterial);
            dragonLeftWing.position.set(-0.5, 0.8, -1.8);
            dragonLeftWing.rotation.z = Math.PI / 6;
            dragonLeftWing.rotation.y = -Math.PI / 6;
            dragonGroup.add(dragonLeftWing);
            dragonWings.push(dragonLeftWing);

            // 오른쪽 날개 (얇은 상자)
            const rightDragonWingGeometry = new THREE.BoxGeometry(0.1, 2.5, 2.0);
            dragonRightWing = new THREE.Mesh(rightDragonWingGeometry, dragonMaterial);
            dragonRightWing.position.set(-0.5, 0.8, 1.8);
            dragonRightWing.rotation.z = Math.PI / 6;
            dragonRightWing.rotation.y = Math.PI / 6;
            dragonGroup.add(dragonRightWing);
            dragonWings.push(dragonRightWing);

            // 꼬리 (원뿔)
            const dragonTailGeometry = new THREE.ConeGeometry(0.4, 2.0, 8); // 더 길고 뾰족하게
            dragonTail = new THREE.Mesh(dragonTailGeometry, dragonMaterial);
            dragonTail.position.set(-4.5, 0.0, 0); // 몸통 끝에 위치
            dragonTail.rotation.z = -Math.PI / 2;
            dragonGroup.add(dragonTail);

            dragonGroup.scale.set(0.7, 0.7, 0.7);
            dragonGroup.position.set(10, 2, 0); // 초기 위치 (숨겨진)
            return dragonGroup;
        }

        // 피카츄 모델 생성 함수
        function createPikachu() {
            const yellowMaterial = new THREE.MeshPhongMaterial({ color: 0xFFD700, flatShading: true }); // 피카츄 노란색
            const redCheekMaterial = new THREE.MeshPhongMaterial({ color: 0xFF0000, flatShading: true }); // 빨간 볼
            const blackTipMaterial = new THREE.MeshPhongMaterial({ color: 0x000000, flatShading: true }); // 검은 귀 끝

            pikachuGroup = new THREE.Group();

            // 몸통 (통통한 구)
            const body = new THREE.Mesh(new THREE.SphereGeometry(0.7, 16, 16), yellowMaterial);
            body.position.y = 0.5;
            pikachuGroup.add(body);

            // 머리 (작은 구)
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.6, 16, 16), yellowMaterial);
            head.position.y = 1.3;
            pikachuGroup.add(head);

            // 귀 (원뿔)
            const earGeometry = new THREE.ConeGeometry(0.2, 0.8, 8);
            const leftEar = new THREE.Mesh(earGeometry, yellowMaterial);
            leftEar.position.set(-0.3, 1.9, -0.2);
            leftEar.rotation.z = -Math.PI / 6;
            leftEar.rotation.x = Math.PI / 12;
            pikachuGroup.add(leftEar);

            const rightEar = new THREE.Mesh(earGeometry, yellowMaterial);
            rightEar.position.set(-0.3, 1.9, 0.2);
            rightEar.rotation.z = Math.PI / 6;
            rightEar.rotation.x = Math.PI / 12;
            pikachuGroup.add(rightEar);

            // 귀 끝 (검은색)
            const earTipGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.3, 8);
            const leftEarTip = new THREE.Mesh(earTipGeometry, blackTipMaterial);
            leftEarTip.position.set(0, 0.4, 0); // 귀 끝에 붙임
            leftEar.add(leftEarTip);

            const rightEarTip = new THREE.Mesh(earTipGeometry, blackTipMaterial);
            rightEarTip.position.set(0, 0.4, 0);
            rightEar.add(rightEarTip);

            // 볼 (빨간 구)
            const leftCheek = new THREE.Mesh(new THREE.SphereGeometry(0.2, 8, 8), redCheekMaterial);
            leftCheek.position.set(0.4, 1.2, -0.4);
            pikachuGroup.add(leftCheek);

            const rightCheek = new THREE.Mesh(new THREE.SphereGeometry(0.2, 8, 8), redCheekMaterial);
            rightCheek.position.set(0.4, 1.2, 0.4);
            pikachuGroup.add(rightCheek);

            // 꼬리 (지그재그)
            const tailMaterial = new THREE.MeshPhongMaterial({ color: 0xFFD700, flatShading: true });
            const tailSegmentGeometry = new THREE.BoxGeometry(0.2, 0.8, 0.2);
            const tailSegment1 = new THREE.Mesh(tailSegmentGeometry, tailMaterial);
            tailSegment1.position.set(-0.7, 0.5, 0);
            pikachuGroup.add(tailSegment1);

            const tailSegment2 = new THREE.Mesh(tailSegmentGeometry, tailMaterial);
            tailSegment2.position.set(-1.0, 0.9, 0);
            tailSegment2.rotation.z = Math.PI / 4;
            pikachuGroup.add(tailSegment2);

            const tailSegment3 = new THREE.Mesh(tailSegmentGeometry, tailMaterial);
            tailSegment3.position.set(-1.3, 0.5, 0);
            tailSegment3.rotation.z = -Math.PI / 4;
            pikachuGroup.add(tailSegment3);

            pikachuGroup.scale.set(0.5, 0.5, 0.5);
            // ground 객체가 생성된 후에 position을 설정하도록 수정
            if (ground) {
                pikachuGroup.position.set(-5, ground.position.y + 1, 0); // 땅 위에
            } else {
                pikachuGroup.position.set(-5, -9, 0); // 임시 위치, ground가 나중에 설정될 것을 대비
            }
            pikachuGroup.visible = false;
            return pikachuGroup;
        }

        // 라이츄 모델 생성 함수
        function createRaichu() {
            const brownMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513, flatShading: true }); // 라이츄 갈색
            const creamMaterial = new THREE.MeshPhongMaterial({ color: 0xF5DEB3, flatShading: true }); // 라이츄 크림색 배
            const yellowCheekMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFF00, flatShading: true }); // 노란 볼
            const earTipMaterial = new THREE.MeshPhongMaterial({ color: 0x000000, flatShading: true }); // 검은 귀 끝

            raichuGroup = new THREE.Group();

            // 몸통 (통통한 구)
            const body = new THREE.Mesh(new THREE.SphereGeometry(0.8, 16, 16), brownMaterial);
            body.position.y = 0.6;
            raichuGroup.add(body);

            // 머리 (작은 구)
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.7, 16, 16), brownMaterial);
            head.position.y = 1.5;
            raichuGroup.add(head);

            // 배 (크림색 반구)
            const bellyGeometry = new THREE.SphereGeometry(0.7, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const belly = new THREE.Mesh(bellyGeometry, creamMaterial);
            belly.position.y = 0.5;
            belly.rotation.x = Math.PI; // 아래로 향하게
            raichuGroup.add(belly);


            // 귀 (원뿔)
            const earGeometry = new THREE.ConeGeometry(0.25, 1.0, 8);
            const leftEar = new THREE.Mesh(earGeometry, brownMaterial);
            leftEar.position.set(-0.4, 2.2, -0.3);
            leftEar.rotation.z = -Math.PI / 5;
            leftEar.rotation.x = Math.PI / 10;
            raichuGroup.add(leftEar);

            const rightEar = new THREE.Mesh(earGeometry, brownMaterial);
            rightEar.position.set(-0.4, 2.2, 0.3);
            rightEar.rotation.z = Math.PI / 5;
            rightEar.rotation.x = Math.PI / 10;
            raichuGroup.add(rightEar);

            // 귀 끝 (검은색)
            const earTipGeometry = new THREE.CylinderGeometry(0.12, 0.12, 0.4, 8);
            const leftEarTip = new THREE.Mesh(earTipGeometry, earTipMaterial);
            leftEarTip.position.set(0, 0.5, 0); // 귀 끝에 붙임
            leftEar.add(leftEarTip);

            const rightEarTip = new THREE.Mesh(earTipGeometry, earTipMaterial);
            rightEarTip.position.set(0, 0.5, 0);
            rightEar.add(rightEarTip);

            // 볼 (노란 구)
            const leftCheek = new THREE.Mesh(new THREE.SphereGeometry(0.25, 8, 8), yellowCheekMaterial);
            leftCheek.position.set(0.5, 1.4, -0.5);
            raichuGroup.add(leftCheek);

            const rightCheek = new THREE.Mesh(new THREE.SphereGeometry(0.25, 8, 8), yellowCheekMaterial);
            rightCheek.position.set(0.5, 1.4, 0.5);
            raichuGroup.add(rightCheek);

            // 꼬리 (번개 모양 - 여러 상자 연결)
            const tailMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513, flatShading: true });
            const lightningMaterial = new THREE.MeshPhongMaterial({ color: 0xFFD700, flatShading: true });

            const tailBase = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 1.5, 8), tailMaterial);
            tailBase.position.set(-0.9, 0.6, 0);
            tailBase.rotation.z = Math.PI / 4;
            raichuGroup.add(tailBase);

            const lightningSegment1 = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.8, 0.2), lightningMaterial);
            lightningSegment1.position.set(-1.8, 1.2, 0);
            lightningSegment1.rotation.z = Math.PI / 4;
            raichuGroup.add(lightningSegment1);

            const lightningSegment2 = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.8, 0.2), lightningMaterial);
            lightningSegment2.position.set(-1.9, 0.8, 0);
            lightningSegment2.rotation.z = -Math.PI / 4;
            raichuGroup.add(lightningSegment2);

            const lightningSegment3 = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.8, 0.2), lightningMaterial);
            lightningSegment3.position.set(-2.2, 1.2, 0);
            lightningSegment3.rotation.z = Math.PI / 4;
            raichuGroup.add(lightningSegment3);


            raichuGroup.scale.set(0.6, 0.6, 0.6);
            // ground 객체가 생성된 후에 position을 설정하도록 수정
            if (ground) {
                raichuGroup.position.set(-6, ground.position.y + 1, -1); // 땅 위에, 피카츄 옆
            } else {
                raichuGroup.position.set(-6, -9, -1); // 임시 위치
            }
            raichuGroup.visible = false;
            return raichuGroup;
        }


        // 피 파티클 생성 함수
        function createBloodParticles(position) {
            const bloodMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // 빨간색
            const particleCount = 20; // 파티클 개수 증가
            const particleGeometry = new THREE.SphereGeometry(0.05, 8, 8); // 작은 구

            for (let i = 0; i < particleCount; i++) {
                const particle = new THREE.Mesh(particleGeometry, bloodMaterial);
                particle.position.copy(position); // 독수리 위치에서 시작

                // 무작위 속도 부여 (더 넓게 퍼지도록)
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.4, // x축 (좌우)
                    (Math.random() - 0.5) * 0.4 + 0.2, // y축 (위로 약간 튀어 오르고)
                    (Math.random() - 0.5) * 0.4  // z축 (앞뒤)
                );
                particle.gravity = -0.018; // 중력 효과 강화

                scene.add(particle);
                bloodParticles.push(particle);
            }
        }

        // 치유 파티클 생성 함수
        function createHealingParticles(position) {
            const healingMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.8 }); // 초록색, 투명
            const particleCount = 10;
            const particleGeometry = new THREE.SphereGeometry(0.08, 8, 8); // 작은 구

            for (let i = 0; i < particleCount; i++) {
                const particle = new THREE.Mesh(particleGeometry, healingMaterial);
                particle.position.copy(position);
                particle.position.x += (Math.random() - 0.5) * 0.5;
                particle.position.y += (Math.random() - 0.5) * 0.5;
                particle.position.z += (Math.random() - 0.5) * 0.5;

                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.05, // 천천히 퍼지도록
                    Math.random() * 0.05 + 0.02, // 위로 떠오르도록
                    (Math.random() - 0.5) * 0.05
                );
                particle.lifetime = Math.random() * 60 + 30; // 0.5초 ~ 1초 수명 (프레임 단위)
                particle.age = 0;

                scene.add(particle);
                healingParticles.push(particle);
            }
        }

        // 구름 생성 함수
        function createCloud(x, y, z) {
            const cloudGroup = new THREE.Group();
            const cloudMaterial = new THREE.MeshLambertMaterial({ color: 0xF5F5F5, transparent: true, opacity: 0.8 }); // 흰색, 투명도
            const baseSize = 0.8;

            // 여러 개의 구를 겹쳐서 구름 모양 만들기
            const sphere1 = new THREE.Mesh(new THREE.SphereGeometry(baseSize * 1.2, 16, 16), cloudMaterial);
            cloudGroup.add(sphere1);

            const sphere2 = new THREE.Mesh(new THREE.SphereGeometry(baseSize * 0.9, 16, 16), cloudMaterial);
            sphere2.position.set(baseSize * 0.8, baseSize * 0.3, baseSize * 0.2);
            cloudGroup.add(sphere2);

            const sphere3 = new THREE.Mesh(new THREE.SphereGeometry(baseSize * 1.0, 16, 16), cloudMaterial);
            sphere3.position.set(-baseSize * 0.7, baseSize * 0.1, -baseSize * 0.3);
            cloudGroup.add(sphere3);

            const sphere4 = new THREE.Mesh(new THREE.SphereGeometry(baseSize * 0.7, 16, 16), cloudMaterial);
            sphere4.position.set(baseSize * 0.3, -baseSize * 0.4, -baseSize * 0.5);
            cloudGroup.add(sphere4);

            cloudGroup.position.set(x, y, z);
            return cloudGroup;
        }

        // 고기 모델 생성 함수
        function createMeat() {
            const meatGeometry = new THREE.BoxGeometry(1.5, 0.5, 1);
            const meatMaterial = new THREE.MeshPhongMaterial({ color: 0x8B0000, flatShading: true }); // 어두운 빨간색 고기
            meatObject = new THREE.Mesh(meatGeometry, meatMaterial);
            meatObject.position.set(0, ground.position.y + 0.25, 0); // 땅 위에 놓이도록
            meatObject.visible = false; // 초기에는 숨김
            return meatObject;
        }

        // 카메라 흔들림 시작 함수
        function startCameraShake(intensity) {
            cameraShakeActive = true;
            cameraShakeIntensity = intensity;
            // 일정 시간 후 흔들림 멈춤
            setTimeout(() => {
                cameraShakeActive = false;
            }, 500); // 0.5초 동안 흔들림
        }

        // 씬 초기화 함수
        function init() {
            // 씬 생성
            scene = new THREE.Scene();

            // 카메라 생성
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 10;

            // 렌더러 생성
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('animationCanvas'), antialias: true });
            resizeCanvas(); // 캔버스 크기 조절
            renderer.setPixelRatio(window.devicePixelRatio);

            // 빛 추가 (주변광)
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            // 빛 추가 (방향광)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(0, 1, 1).normalize();
            scene.add(directionalLight);

            // 땅 생성 (피카츄/라이츄 및 고기 생성 전에 먼저 생성되어야 함)
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513, side: THREE.DoubleSide }); // 갈색 땅
            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = Math.PI / 2; // 평평하게 눕힘
            ground.position.y = -10; // 아래쪽에 위치
            scene.add(ground);

            // 독수리 및 용 모델 생성
            eagleGroup = createEagle();
            scene.add(eagleGroup);

            dragonGroup = createDragon();
            scene.add(dragonGroup);

            // 피카츄와 라이츄 모델 생성 (초기에는 숨김)
            pikachuGroup = createPikachu();
            scene.add(pikachuGroup);

            raichuGroup = createRaichu();
            scene.add(raichuGroup);

            // 고기 모델 생성 (초기에는 숨김)
            meatObject = createMeat();
            scene.add(meatObject);

            // 구름 생성 및 추가
            for(let i = 0; i < 8; i++) {
                const cloud = createCloud(
                    (Math.random() - 0.5) * 30, // x
                    (Math.random() - 0.5) * 10 + 5, // y (하늘 위)
                    (Math.random() - 0.5) * 20 - 10 // z (깊이감)
                );
                scene.add(cloud);
                clouds.push(cloud);
            }


            // 이벤트 리스너 설정
            window.addEventListener('resize', onWindowResize, false);
            document.getElementById('startButton').addEventListener('click', startAnimation);
            document.getElementById('resetButton').addEventListener('click', resetAnimation);
            document.getElementById('animationCanvas').addEventListener('mousedown', onMouseDown, false);
            document.getElementById('animationCanvas').addEventListener('mouseup', onMouseUp, false);
            document.getElementById('animationCanvas').addEventListener('touchstart', onTouchStart, false);
            document.getElementById('animationCanvas').addEventListener('touchend', onTouchEnd, false);

            initSpeechSynthesis(); // 음성 합성 초기화
        }

        // 캔버스 크기 조절
        function resizeCanvas() {
            const width = window.innerWidth * 0.9;
            const height = window.innerHeight * 0.6;
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        }

        // 창 크기 변경 시 호출
        function onWindowResize() {
            resizeCanvas();
        }

        let isDragging = false;
        let previousMouseX = 0;
        let previousMouseY = 0;

        function onMouseDown(event) {
            isDragging = true;
            previousMouseX = event.clientX;
            previousMouseY = event.clientY;
            document.getElementById('animationCanvas').addEventListener('mousemove', onMouseMove, false);
        }

        function onMouseUp() {
            isDragging = false;
            document.getElementById('animationCanvas').removeEventListener('mousemove', onMouseMove, false);
        }

        function onMouseMove(event) {
            if (!isDragging) return;

            const deltaX = event.clientX - previousMouseX;
            const deltaY = event.clientY - previousMouseY;

            targetRotationY += deltaX * 0.01;
            targetRotationX += deltaY * 0.01;

            // X축 회전 제한 (위아래 과도한 회전 방지)
            targetRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, targetRotationX));

            previousMouseX = event.clientX;
            previousMouseY = event.clientY;
        }

        // 터치 이벤트 처리
        function onTouchStart(event) {
            if (event.touches.length === 1) {
                isDragging = true;
                previousMouseX = event.touches[0].clientX;
                previousMouseY = event.touches[0].clientY;
                document.getElementById('animationCanvas').addEventListener('touchmove', onTouchMove, false);
            }
        }

        function onTouchEnd() {
            isDragging = false;
            document.getElementById('animationCanvas').removeEventListener('touchmove', onTouchMove, false);
        }

        function onTouchMove(event) {
            if (!isDragging || event.touches.length !== 1) return;

            const deltaX = event.touches[0].clientX - previousMouseX;
            const deltaY = event.touches[0].clientY - previousMouseY;

            targetRotationY += deltaX * 0.01;
            targetRotationX += deltaY * 0.01;

            targetRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, targetRotationX));

            previousMouseX = event.touches[0].clientX;
            previousMouseY = event.touches[0].clientY;
        }

        // 독수리 원래 색상
        const originalEagleBodyColor = new THREE.Color(0x8B4513);
        const originalEagleHeadColor = new THREE.Color(0xF8F8F8);
        const originalEagleLegColor = new THREE.Color(0xDAA520);


        // 애니메이션 루프
        function animate() {
            animationFrameId = requestAnimationFrame(animate);

            if (!isAnimating) return;

            wingFlapTime += 0.1;
            stateTimer++;

            // 구름 이동
            clouds.forEach(cloud => {
                cloud.position.x += 0.01; // 천천히 왼쪽으로 이동
                if (cloud.position.x > 15) { // 화면 밖으로 나가면 다시 오른쪽으로 이동
                    cloud.position.x = -15;
                }
            });

            // 피 파티클 움직임 업데이트 및 제거
            for (let i = bloodParticles.length - 1; i >= 0; i--) {
                const particle = bloodParticles[i];
                particle.position.x += particle.velocity.x;
                particle.position.y += particle.velocity.y;
                particle.position.z += particle.velocity.z;
                particle.velocity.y += particle.gravity;

                // 일정 시간 후 또는 화면 아래로 사라지면 제거
                if (particle.position.y < ground.position.y - 1 || particle.position.y > 15 || particle.position.x < -20 || particle.position.x > 20 || particle.position.z < -20 || particle.position.z > 20) {
                    scene.remove(particle);
                    bloodParticles.splice(i, 1);
                }
            }

            // 치유 파티클 움직임 업데이트 및 제거
            for (let i = healingParticles.length - 1; i >= 0; i--) {
                const particle = healingParticles[i];
                particle.position.x += particle.velocity.x;
                particle.position.y += particle.velocity.y;
                particle.position.z += particle.velocity.z;
                particle.age++;

                // 투명도 조절 (사라지게)
                particle.material.opacity = (particle.lifetime - particle.age) / particle.lifetime;

                if (particle.age > particle.lifetime) {
                    scene.remove(particle);
                    healingParticles.splice(i, 1);
                }
            }


            switch (currentGameState) {
                case GameState.EAGLE_FLYING:
                    // 독수리 날개 움직임
                    eagleLeftWing.rotation.x = Math.sin(wingFlapTime * 0.7) * 0.6;
                    eagleRightWing.rotation.x = -Math.sin(wingFlapTime * 0.7) * 0.6;
                    // 독수리 이동
                    eagleGroup.position.x += eagleSpeed;
                    if (eagleGroup.position.x > 0 && !dragonAppeared) {
                        currentGameState = GameState.DRAGON_APPEARING;
                        speakMessage("독수리가 하늘을 멋지게 날아가고 있어요!");
                        dragonAppeared = true;
                        dragonGroup.position.set(8, 2, 0);
                        dragonGroup.scale.set(0.7, 0.7, 0.7);
                    }
                    break;

                case GameState.DRAGON_APPEARING:
                    // 독수리 날개 움직임
                    eagleLeftWing.rotation.x = Math.sin(wingFlapTime * 0.7) * 0.6;
                    eagleRightWing.rotation.x = -Math.sin(wingFlapTime * 0.7) * 0.6;
                    // 용 날개 움직임
                    dragonLeftWing.rotation.x = Math.sin(wingFlapTime * 0.4) * 0.4;
                    dragonRightWing.rotation.x = -Math.sin(wingFlapTime * 0.4) * 0.4;
                    // 용 몸통 구불거림
                    dragonGroup.rotation.z = Math.sin(wingFlapTime * 0.2) * 0.1;
                    dragonGroup.rotation.y = Math.sin(wingFlapTime * 0.15) * 0.05;

                    const direction = new THREE.Vector3().subVectors(eagleGroup.position, dragonGroup.position).normalize();
                    dragonGroup.position.add(direction.multiplyScalar(dragonSpeed));
                    eagleGroup.position.x += eagleSpeed * 0.5; // 독수리도 조금씩 이동

                    if (dragonGroup.position.distanceTo(eagleGroup.position) < 1.5) {
                        currentGameState = GameState.COLLISION;
                        speakMessage("앗! 무서운 용이 나타났어요!");
                        eagleDying = true;
                        // 독수리 색깔 변경
                        eagleBody.material.color.set(0x808080);
                        eagleHead.material.color.set(0x808080);
                        eagleLeftWing.material.color.set(0x808080);
                        eagleRightWing.material.color.set(0x808080);
                        eagleTail.material.color.set(0x808080);
                        eagleLeftLeg.material.color.set(0x808080);
                        eagleRightLeg.material.color.set(0x808080);

                        createBloodParticles(eagleGroup.position);
                        startCameraShake(0.1);
                        stateTimer = 0; // 충돌 후 타이머 초기화
                    }
                    break;

                case GameState.COLLISION:
                    // 독수리 날개 멈춤
                    eagleLeftWing.rotation.x = 0;
                    eagleRightWing.rotation.x = 0;
                    // 독수리 떨어짐
                    eagleGroup.position.y -= 0.1;
                    eagleGroup.rotation.z += 0.1;
                    if (eagleGroup.position.y < ground.position.y + 0.5) {
                        eagleGroup.position.y = ground.position.y + 0.5; // 땅에 고정
                        currentGameState = GameState.EAGLE_FALLEN;
                        speakMessage("용과 독수리가 싸우고 있어요! 독수리가 쓰러졌어요...");
                        stateTimer = 0;
                    }
                    break;

                case GameState.EAGLE_FALLEN:
                    // 독수리는 땅에 고정된 상태
                    if (stateTimer > stateDurations[GameState.EAGLE_FALLEN]) {
                        pikachuGroup.visible = true;
                        raichuGroup.visible = true;
                        // 피카츄와 라이츄를 독수리 근처로 이동 (애니메이션 시작 시점은 여기에)
                        pikachuGroup.position.x = eagleGroup.position.x + 1;
                        pikachuGroup.position.y = ground.position.y + 0.5;
                        raichuGroup.position.x = eagleGroup.position.x - 1;
                        raichuGroup.position.y = ground.position.y + 0.5;
                        currentGameState = GameState.ENCOUNTER_POKEMON;
                        speakMessage("피카츄와 라이츄가 독수리에게 다가옵니다!");
                        stateTimer = 0;
                    }
                    break;

                case GameState.ENCOUNTER_POKEMON:
                    // 피카츄와 라이츄가 독수리 주변을 움직임
                    pikachuGroup.position.x = eagleGroup.position.x + 1 + Math.sin(wingFlapTime * 0.3) * 0.5;
                    raichuGroup.position.x = eagleGroup.position.x - 1 + Math.cos(wingFlapTime * 0.3) * 0.5;
                    pikachuGroup.position.z = Math.sin(wingFlapTime * 0.5) * 0.3;
                    raichuGroup.position.z = Math.cos(wingFlapTime * 0.5) * 0.3;

                    // 피카츄와 라이츄가 제자리에서 살짝 위아래로 움직이도록 (발구르기 효과)
                    pikachuGroup.position.y = ground.position.y + 0.5 + Math.sin(wingFlapTime * 0.8) * 0.1;
                    raichuGroup.position.y = ground.position.y + 0.5 + Math.cos(wingFlapTime * 0.8) * 0.1;


                    if (stateTimer > stateDurations[GameState.ENCOUNTER_POKEMON]) {
                        currentGameState = GameState.EAGLE_REVIVING;
                        speakMessage("피카츄와 라이츄가 독수리를 치료하고 있어요!");
                        stateTimer = 0;
                    }
                    break;

                case GameState.EAGLE_REVIVING:
                    // 독수리 천천히 떠오르기
                    eagleGroup.position.y = ground.position.y + 0.5 + Math.sin(stateTimer * 0.05) * 2; // 위로 떠오르는 애니메이션
                    eagleGroup.rotation.z = 0; // 회전 멈춤

                    // 독수리 색상 원래대로 돌아오기
                    const progress = stateTimer / stateDurations[GameState.EAGLE_REVIVING];
                    eagleBody.material.color.lerp(originalEagleBodyColor, progress);
                    eagleHead.material.color.lerp(originalEagleHeadColor, progress);
                    eagleLeftWing.material.color.lerp(originalEagleBodyColor, progress);
                    eagleRightWing.material.color.lerp(originalEagleBodyColor, progress);
                    eagleTail.material.color.lerp(originalEagleBodyColor, progress);
                    eagleLeftLeg.material.color.lerp(originalEagleLegColor, progress);
                    eagleRightLeg.material.color.lerp(originalEagleLegColor, progress);

                    // 피카츄 라이츄는 독수리 따라 움직임 + 맥박 효과
                    pikachuGroup.position.x = eagleGroup.position.x + 1;
                    pikachuGroup.position.y = eagleGroup.position.y - 0.5;
                    raichuGroup.position.x = eagleGroup.position.x - 1;
                    raichuGroup.position.y = eagleGroup.position.y - 0.5;

                    const pulseScale = 1 + Math.sin(wingFlapTime * 0.5) * 0.05; // 5% 크기 변화
                    pikachuGroup.scale.set(0.5 * pulseScale, 0.5 * pulseScale, 0.5 * pulseScale);
                    raichuGroup.scale.set(0.6 * pulseScale, 0.6 * pulseScale, 0.6 * pulseScale);

                    // 치유 파티클 계속 생성
                    if (stateTimer % 10 === 0) { // 10프레임마다 생성
                        createHealingParticles(eagleGroup.position);
                    }


                    if (stateTimer > stateDurations[GameState.EAGLE_REVIVING]) {
                        currentGameState = GameState.EAGLE_FLYING_AWAY;
                        speakMessage("독수리가 다시 날아올라요! 피카츄, 라이츄와 함께요!");
                        stateTimer = 0;
                        // 피카츄 라이츄 원래 크기로 복원
                        pikachuGroup.scale.set(0.5, 0.5, 0.5);
                        raichuGroup.scale.set(0.6, 0.6, 0.6);
                    }
                    break;

                case GameState.EAGLE_FLYING_AWAY:
                    // 독수리, 피카츄, 라이츄 함께 날아감
                    eagleGroup.position.x += eagleSpeed * 0.8;
                    eagleGroup.position.y += eagleSpeed * 0.5;
                    eagleGroup.scale.multiplyScalar(0.995); // 작아지면서 멀어지는 효과

                    pikachuGroup.position.x = eagleGroup.position.x + 1;
                    pikachuGroup.position.y = eagleGroup.position.y - 0.5;
                    pikachuGroup.scale.multiplyScalar(0.995);

                    raichuGroup.position.x = eagleGroup.position.x - 1;
                    raichuGroup.position.y = eagleGroup.position.y - 0.5;
                    raichuGroup.scale.multiplyScalar(0.995);

                    // 독수리 날개 움직임 다시 시작
                    eagleLeftWing.rotation.x = Math.sin(wingFlapTime * 0.7) * 0.6;
                    eagleRightWing.rotation.x = -Math.sin(wingFlapTime * 0.7) * 0.6;

                    // 용은 그냥 사라짐
                    dragonGroup.visible = false;

                    // 모든 치유 파티클 제거
                    healingParticles.forEach(p => scene.remove(p));
                    healingParticles = [];

                    if (eagleGroup.scale.x < 0.1) {
                        currentGameState = GameState.DRAGON_EATING; // 용이 고기 먹는 장면으로 전환
                        stateTimer = 0;
                        speakMessage("독수리가 날아가고, 용이 고기를 맛있게 먹어요!");

                        // 용과 고기를 먹는 위치로 설정
                        dragonGroup.visible = true;
                        dragonGroup.position.set(0, ground.position.y + 2, 0); // 용을 땅 위로
                        dragonGroup.rotation.set(0, Math.PI, 0); // 카메라를 향하도록 회전
                        meatObject.visible = true;
                        meatObject.position.set(0.5, ground.position.y + 0.25, 1); // 고기를 용 옆에
                    }
                    break;

                case GameState.DRAGON_EATING:
                    // 용이 고기를 먹는 애니메이션
                    dragonHead.rotation.x = Math.sin(wingFlapTime * 0.5) * 0.2 + 0.2; // 머리를 숙였다 들었다
                    dragonGroup.position.y = ground.position.y + 2 + Math.sin(wingFlapTime * 0.2) * 0.1; // 몸통도 살짝 움직임

                    // 고기가 점점 작아지게
                    const meatScaleProgress = 1 - (stateTimer / stateDurations[GameState.DRAGON_EATING]);
                    if (meatScaleProgress > 0) {
                        meatObject.scale.set(meatScaleProgress, meatScaleProgress, meatScaleProgress);
                    } else {
                        meatObject.visible = false; // 고기가 다 사라지면 숨김
                    }

                    if (stateTimer > stateDurations[GameState.DRAGON_EATING]) {
                        currentGameState = GameState.FINISHED;
                        speakMessage("이야기 끝! 다음에 또 만나요!");
                        cancelAnimationFrame(animationFrameId);
                    }
                    break;

                case GameState.FINISHED:
                    // 애니메이션 종료 상태
                    break;
            }


            // 카메라 회전 부드럽게 적용
            currentRotationX += (targetRotationX - currentRotationX) * rotationSpeed;
            currentRotationY += (targetRotationY - currentRotationY) * rotationSpeed;

            let shakeOffsetX = 0, shakeOffsetY = 0, shakeOffsetZ = 0;
            if (cameraShakeActive) {
                shakeOffsetX = (Math.random() - 0.5) * cameraShakeIntensity;
                shakeOffsetY = (Math.random() - 0.5) * cameraShakeIntensity;
                shakeOffsetZ = (Math.random() - 0.5) * cameraShakeIntensity;
            }

            // 카메라 위치를 독수리/그룹을 따라가도록 조정
            let cameraLookAtTarget = new THREE.Vector3(0,0,0);
            if (currentGameState === GameState.EAGLE_FALLEN || currentGameState === GameState.ENCOUNTER_POKEMON || currentGameState === GameState.EAGLE_REVIVING) {
                cameraLookAtTarget.copy(eagleGroup.position);
                camera.position.x = eagleGroup.position.x + 5 * Math.sin(currentRotationY) * Math.cos(currentRotationX) + shakeOffsetX;
                camera.position.y = eagleGroup.position.y + 5 * Math.sin(currentRotationX) + 2 + shakeOffsetY; // 좀 더 위에서 내려다보도록
                camera.position.z = eagleGroup.position.z + 5 * Math.cos(currentRotationY) * Math.cos(currentRotationX) + shakeOffsetZ;
            } else if (currentGameState === GameState.EAGLE_FLYING_AWAY) {
                cameraLookAtTarget.copy(eagleGroup.position);
                camera.position.x = eagleGroup.position.x - 5 + shakeOffsetX; // 독수리를 뒤에서 따라가도록
                camera.position.y = eagleGroup.position.y + 3 + shakeOffsetY;
                camera.position.z = eagleGroup.position.z + 5 * Math.cos(currentRotationY) * Math.cos(currentRotationX) + shakeOffsetZ;
            } else if (currentGameState === GameState.DRAGON_EATING) { // 용이 고기 먹는 장면 카메라
                cameraLookAtTarget.copy(dragonGroup.position);
                camera.position.x = dragonGroup.position.x + 3 * Math.sin(currentRotationY) * Math.cos(currentRotationX) + shakeOffsetX;
                camera.position.y = dragonGroup.position.y + 3 * Math.sin(currentRotationX) + 1 + shakeOffsetY;
                camera.position.z = dragonGroup.position.z + 3 * Math.cos(currentRotationY) * Math.cos(currentRotationX) + shakeOffsetZ;
            }
            else {
                // 초기 비행 및 충돌 전에는 기존 카메라 로직 유지
                camera.position.x = 10 * Math.sin(currentRotationY) * Math.cos(currentRotationX) + shakeOffsetX;
                camera.position.y = 10 * Math.sin(currentRotationX) + shakeOffsetY;
                camera.position.z = 10 * Math.cos(currentRotationY) * Math.cos(currentRotationX) + shakeOffsetZ;
            }
            camera.lookAt(cameraLookAtTarget); // 항상 대상을 바라보게


            renderer.render(scene, camera);
        }

        // 애니메이션 시작
        function startAnimation() {
            if (!isAnimating) {
                isAnimating = true;
                currentGameState = GameState.EAGLE_FLYING;
                dragonAppeared = false;
                eagleDying = false;
                cameraShakeActive = false;
                stateTimer = 0;

                // 독수리 초기화
                eagleGroup.position.set(-8, 2, 0);
                eagleGroup.rotation.set(0, 0, 0);
                eagleGroup.scale.set(0.8, 0.8, 0.8);
                eagleBody.material.color.set(originalEagleBodyColor.getHex());
                eagleHead.material.color.set(originalEagleHeadColor.getHex());
                eagleLeftWing.material.color.set(originalEagleBodyColor.getHex());
                eagleRightWing.material.color.set(originalEagleBodyColor.getHex());
                eagleTail.material.color.set(originalEagleBodyColor.getHex());
                eagleLeftLeg.material.color.set(originalEagleLegColor.getHex());
                eagleRightLeg.material.color.set(originalEagleLegColor.getHex());

                // 용 초기화
                dragonGroup.position.set(10, 2, 0);
                dragonGroup.scale.set(0.7, 0.7, 0.7);
                dragonGroup.rotation.set(0,0,0);
                dragonGroup.visible = true; // 용 다시 보이게

                // 피카츄, 라이츄 초기화 및 숨김
                pikachuGroup.position.set(-5, ground.position.y + 1, 0);
                pikachuGroup.scale.set(0.5, 0.5, 0.5);
                pikachuGroup.visible = false;

                raichuGroup.position.set(-6, ground.position.y + 1, -1);
                raichuGroup.scale.set(0.6, 0.6, 0.6);
                raichuGroup.visible = false;

                // 고기 초기화 및 숨김
                meatObject.scale.set(1, 1, 1); // 고기 크기 원래대로
                meatObject.visible = false;

                wingFlapTime = 0;
                window.speechSynthesis.cancel(); // 애니메이션 시작 시 모든 음성 중단

                // 모든 피 파티클 제거
                bloodParticles.forEach(p => scene.remove(p));
                bloodParticles = [];

                // 모든 치유 파티클 제거
                healingParticles.forEach(p => scene.remove(p));
                healingParticles = [];

                // 초기 메시지 재생
                speakMessage("독수리와 용, 그리고 피카츄와 라이츄 이야기 시작!");

                animate();
            }
        }

        // 애니메이션 초기화 (다시 시작)
        function resetAnimation() {
            cancelAnimationFrame(animationFrameId);
            isAnimating = false;
            currentGameState = GameState.INITIAL;
            dragonAppeared = false;
            eagleDying = false;
            cameraShakeActive = false;
            stateTimer = 0;

            // 객체 위치 및 상태 초기화
            eagleGroup.position.set(-8, 2, 0);
            eagleGroup.rotation.set(0, 0, 0);
            eagleGroup.scale.set(0.8, 0.8, 0.8);
            eagleBody.material.color.set(originalEagleBodyColor.getHex());
            eagleHead.material.color.set(originalEagleHeadColor.getHex());
            eagleLeftWing.material.color.set(originalEagleBodyColor.getHex());
            eagleRightWing.material.color.set(originalEagleBodyColor.getHex());
            eagleTail.material.color.set(originalEagleBodyColor.getHex());
            eagleLeftLeg.material.color.set(originalEagleLegColor.getHex());
            eagleRightLeg.material.color.set(originalEagleLegColor.getHex());


            dragonGroup.position.set(10, 2, 0);
            dragonGroup.scale.set(0.7, 0.7, 0.7);
            dragonGroup.rotation.set(0,0,0);
            dragonGroup.visible = true;

            pikachuGroup.position.set(-5, ground.position.y + 1, 0);
            pikachuGroup.scale.set(0.5, 0.5, 0.5);
            pikachuGroup.visible = false;

            raichuGroup.position.set(-6, ground.position.y + 1, -1);
            raichuGroup.scale.set(0.6, 0.6, 0.6);
            raichuGroup.visible = false;

            // 고기 초기화 및 숨김
            meatObject.scale.set(1, 1, 1);
            meatObject.visible = false;

            wingFlapTime = 0;

            window.speechSynthesis.cancel(); // 애니메이션 리셋 시 모든 음성 중단

            // 모든 피 파티클 제거
            bloodParticles.forEach(p => scene.remove(p));
            bloodParticles = [];

            // 모든 치유 파티클 제거
            healingParticles.forEach(p => scene.remove(p));
            healingParticles = [];

            renderer.render(scene, camera); // 초기화된 상태 렌더링
        }

        // 윈도우 로드 시 초기화
        window.onload = function () {
            init();
            renderer.render(scene, camera); // 초기 씬 렌더링
        };
    </script>
</body>
